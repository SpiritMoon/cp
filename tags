!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACK_AUTH	header.h	122;"	d
ACK_CHALLENGE	header.h	120;"	d
ACK_INFO	header.h	129;"	d
ACK_LOGOUT	header.h	125;"	d
AC_TO_PORTAL_PORT	header.h	19;"	d
AFF_ACK_AUTH	header.h	126;"	d
CC	Makefile	/^CC=gcc$/;"	m
CONFIG_FILE_NAME	header.h	16;"	d
Challenge	header.h	135;"	d
ChapPassWord	header.h	136;"	d
DEPEND	Makefile	/^DEPEND=main.o logs.o ini.o net.o server_mutual.o radius.o portal.o cJSON.o$/;"	m
IS_DAEMON_EXIST	header.h	9;"	d
LIB	Makefile	/^LIB=-lpthread -lm$/;"	m
LOGS_MAX_SIZE	header.h	11;"	d
MAKE	Makefile	/^MAKE=make$/;"	m
MAX_EPOLL_NUM	header.h	14;"	d
NTF_LOGOUT	header.h	127;"	d
PORTAL_IP_LEN	header.h	164;"	d
PORTAL_MAC_LEN	header.h	165;"	d
PORTAL_PASSWORD_LEN	header.h	163;"	d
PORTAL_TO_AC_PORT	header.h	18;"	d
PORTAL_USERNAME_LEN	header.h	162;"	d
PUBLIC_DEPEND	Makefile	/^PUBLIC_DEPEND=$(PUBDIR)\/*.o$/;"	m
PassWord	header.h	134;"	d
REQ_AUTH	header.h	121;"	d
REQ_CHALLENGE	header.h	119;"	d
REQ_INFO	header.h	128;"	d
REQ_LOGOUT	header.h	123;"	d
SERVER_MUTUAL_DEBUG	server_mutual.c	20;"	d	file:
SOURCE	Makefile	/^SOURCE=main.c logs.c ini.c net.c server_mutual.c radius.c portal.c cJSON.c$/;"	m
ST_PORTAL_AC	header.h	/^}ST_PORTAL_AC;$/;"	t	typeref:struct:portal_ac
ST_PORTAL_AC_ATTR	header.h	/^}ST_PORTAL_AC_ATTR;$/;"	t	typeref:struct:portal_ac_attr
ST_REQ_AUTH	header.h	/^}ST_REQ_AUTH;$/;"	t	typeref:struct:req_auth
ST_REQ_MAC_QUERY	header.h	/^}ST_REQ_MAC_QUERY;$/;"	t	typeref:struct:req_mac_query
SendReqAuthAndRecv	portal.c	/^int SendReqAuthAndRecv(ST_REQ_AUTH *req_auth, char* ac_ip, int port)$/;"	f
SendReqLogoutAndRecv	portal.c	/^int SendReqLogoutAndRecv(char* userip, char* ac_ip, int port)$/;"	f
TARGET	Makefile	/^TARGET=cp.out$/;"	m
UDP_create	net.c	/^int UDP_create(int *sockfd)$/;"	f
UDP_recv_block	net.c	/^int UDP_recv_block(int socket, unsigned char *rcvBuf, int slLen)$/;"	f
UDP_send_block	net.c	/^int UDP_send_block(int socket, char* ip, int port, unsigned char *buf, int len)$/;"	f
UserName	header.h	133;"	d
WRITE_LOG	header.h	12;"	d
WT_HEADER_H	header.h	7;"	d
ac_attr	header.h	/^	char ac_attr[512];$/;"	m	struct:portal_ac
acip	header.h	/^    char acip[PORTAL_IP_LEN]; $/;"	m	struct:req_mac_query
attrNum	header.h	/^	unsigned char attrNum;		\/\/ 表示其后边可变长度的属性字段属性的个数，长度为 1 字节$/;"	m	struct:portal_ac
attrVal	header.h	/^	unsigned char attrVal[253];$/;"	m	struct:portal_ac_attr
attributes	radius.c	/^	struct radius_attr attributes[0];$/;"	m	struct:radius_bag	typeref:struct:radius_bag::radius_attr	file:
authenticator	radius.c	/^	unsigned char authenticator[16];	\/\/md5$/;"	m	struct:radius_bag	file:
buf	radius.c	/^	char buf[1024];$/;"	m	struct:radius_recv	file:
cJSON	cJSON.h	/^typedef struct cJSON {$/;"	s
cJSON	cJSON.h	/^} cJSON;$/;"	t	typeref:struct:cJSON
cJSON_AddFalseToObject	cJSON.h	121;"	d
cJSON_AddItemReferenceToArray	cJSON.c	/^void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}$/;"	f
cJSON_AddItemReferenceToObject	cJSON.c	/^void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}$/;"	f
cJSON_AddItemToArray	cJSON.c	/^void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}$/;"	f
cJSON_AddItemToObject	cJSON.c	/^void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}$/;"	f
cJSON_AddNullToObject	cJSON.h	119;"	d
cJSON_AddNumberToObject	cJSON.h	122;"	d
cJSON_AddStringToObject	cJSON.h	123;"	d
cJSON_AddTrueToObject	cJSON.h	120;"	d
cJSON_Array	cJSON.h	39;"	d
cJSON_CreateArray	cJSON.c	/^cJSON *cJSON_CreateArray()						{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}$/;"	f
cJSON_CreateBool	cJSON.c	/^cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}$/;"	f
cJSON_CreateDoubleArray	cJSON.c	/^cJSON *cJSON_CreateDoubleArray(double *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateFalse	cJSON.c	/^cJSON *cJSON_CreateFalse()						{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}$/;"	f
cJSON_CreateFloatArray	cJSON.c	/^cJSON *cJSON_CreateFloatArray(float *numbers,int count)			{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateIntArray	cJSON.c	/^cJSON *cJSON_CreateIntArray(int *numbers,int count)				{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateNull	cJSON.c	/^cJSON *cJSON_CreateNull()						{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}$/;"	f
cJSON_CreateNumber	cJSON.c	/^cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}$/;"	f
cJSON_CreateObject	cJSON.c	/^cJSON *cJSON_CreateObject()						{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}$/;"	f
cJSON_CreateString	cJSON.c	/^cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}$/;"	f
cJSON_CreateStringArray	cJSON.c	/^cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateTrue	cJSON.c	/^cJSON *cJSON_CreateTrue()						{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}$/;"	f
cJSON_Delete	cJSON.c	/^void cJSON_Delete(cJSON *c)$/;"	f
cJSON_DeleteItemFromArray	cJSON.c	/^void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}$/;"	f
cJSON_DeleteItemFromObject	cJSON.c	/^void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}$/;"	f
cJSON_DetachItemFromArray	cJSON.c	/^cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;$/;"	f
cJSON_DetachItemFromObject	cJSON.c	/^cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}$/;"	f
cJSON_False	cJSON.h	34;"	d
cJSON_GetArrayItem	cJSON.c	/^cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}$/;"	f
cJSON_GetArraySize	cJSON.c	/^int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}$/;"	f
cJSON_GetErrorPtr	cJSON.c	/^const char *cJSON_GetErrorPtr() {return ep;}$/;"	f
cJSON_GetObjectItem	cJSON.c	/^cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}$/;"	f
cJSON_Hooks	cJSON.h	/^typedef struct cJSON_Hooks {$/;"	s
cJSON_Hooks	cJSON.h	/^} cJSON_Hooks;$/;"	t	typeref:struct:cJSON_Hooks
cJSON_InitHooks	cJSON.c	/^void cJSON_InitHooks(cJSON_Hooks* hooks)$/;"	f
cJSON_IsReference	cJSON.h	42;"	d
cJSON_NULL	cJSON.h	36;"	d
cJSON_New_Item	cJSON.c	/^static cJSON *cJSON_New_Item()$/;"	f	file:
cJSON_Number	cJSON.h	37;"	d
cJSON_Object	cJSON.h	40;"	d
cJSON_Parse	cJSON.c	/^cJSON *cJSON_Parse(const char *value)$/;"	f
cJSON_Print	cJSON.c	/^char *cJSON_Print(cJSON *item)				{return print_value(item,0,1);}$/;"	f
cJSON_PrintUnformatted	cJSON.c	/^char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0);}$/;"	f
cJSON_ReplaceItemInArray	cJSON.c	/^void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;$/;"	f
cJSON_ReplaceItemInObject	cJSON.c	/^void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}$/;"	f
cJSON_String	cJSON.h	38;"	d
cJSON_True	cJSON.h	35;"	d
cJSON__h	cJSON.h	24;"	d
cJSON_free	cJSON.c	/^static void (*cJSON_free)(void *ptr) = free;$/;"	v	file:
cJSON_malloc	cJSON.c	/^static void *(*cJSON_malloc)(size_t sz) = malloc;$/;"	v	file:
cJSON_strcasecmp	cJSON.c	/^static int cJSON_strcasecmp(const char *s1,const char *s2)$/;"	f	file:
cJSON_strdup	cJSON.c	/^static char* cJSON_strdup(const char* str)$/;"	f	file:
cgv_platform_port	main.c	/^int	 cgv_platform_port = 5633;					\/\/ 开放给平台的端口$/;"	v
cgv_sql_name	main.c	/^char cgv_sql_name[32];					\/\/ sql name$/;"	v
cgv_sql_pass	main.c	/^char cgv_sql_pass[32];					\/\/ sql password$/;"	v
cgv_sql_user	main.c	/^char cgv_sql_user[32];					\/\/ sql user$/;"	v
child	cJSON.h	/^	struct cJSON *child;		\/* An array or object item will have a child pointer pointing to a chain of the items in the array\/object. *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
client	radius.c	/^	struct sockaddr_in client;$/;"	m	struct:radius_recv	typeref:struct:radius_recv::sockaddr_in	file:
code	radius.c	/^	unsigned char code;			\/\/$/;"	m	struct:radius_bag	file:
create_reference	cJSON.c	/^static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}$/;"	f	file:
destroy_ini	ini.c	/^void destroy_ini(int fd)$/;"	f
ep	cJSON.c	/^static const char *ep;$/;"	v	file:
errCode	header.h	/^	unsigned char errCode;		\/\/ ErrCode字段和Type字段一起表示一定的意义，长度为 1字节$/;"	m	struct:portal_ac
firstByteMark	cJSON.c	/^static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };$/;"	v	file:
free_fn	cJSON.h	/^      void (*free_fn)(void *ptr);$/;"	m	struct:cJSON_Hooks
generateSerialNo	portal.c	/^unsigned short generateSerialNo()$/;"	f
get_config	main.c	/^int get_config()$/;"	f
get_ini	ini.c	/^int get_ini(char *buf, const char* key, char* value)$/;"	f
get_plat_para	server_mutual.c	/^int get_plat_para(cJSON *json, struct plat_para *para)$/;"	f
identifier	radius.c	/^	unsigned char identifier;	\/\/$/;"	m	struct:radius_bag	file:
init_ini	ini.c	/^int init_ini(char* filename, int *fd, char* buf, int len)$/;"	f
len	header.h	/^	unsigned char len;$/;"	m	struct:portal_ac_attr
length	radius.c	/^	unsigned char length;$/;"	m	struct:radius_attr	file:
length	radius.c	/^	unsigned short length;		\/\/ 长度$/;"	m	struct:radius_bag	file:
log_day	logs.c	/^int				log_day;			\/\/ 当前log文件对应的日期-天$/;"	v
log_name	logs.c	/^char			log_name[32];		\/\/ log文件前缀名$/;"	v
logs_buf	logs.c	/^static char logs_buf[2048];			\/\/ log内容$/;"	v	file:
logs_create	logs.c	/^int logs_create()$/;"	f
logs_destroy	logs.c	/^void logs_destroy()$/;"	f
logs_fd	logs.c	/^int				logs_fd		= 0;	\/\/ 文件描述符$/;"	v
logs_init	logs.c	/^int logs_init(char* prefix)$/;"	f
logs_lock	logs.c	/^pthread_mutex_t logs_lock;			\/\/ log写入全局互斥锁$/;"	v
logs_mytime	logs.c	/^static struct tm *logs_mytime;		\/\/ log时间$/;"	v	typeref:struct:tm	file:
logs_ret	logs.c	/^static int logs_strlen,logs_ret;	\/\/$/;"	v	file:
logs_strlen	logs.c	/^static int logs_strlen,logs_ret;	\/\/$/;"	v	file:
logs_temp	logs.c	/^static char logs_temp[2048];		\/\/ log内容临时存放$/;"	v	file:
logs_tm	logs.c	/^static time_t logs_tm;				\/\/ log时间$/;"	v	file:
main	main.c	/^int main(int argc, char** argv)$/;"	f
malloc_fn	cJSON.h	/^      void *(*malloc_fn)(size_t sz);$/;"	m	struct:cJSON_Hooks
name	header.h	/^    char name[PORTAL_USERNAME_LEN];$/;"	m	struct:req_auth
next	cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
pap_chap	header.h	/^	unsigned char pap_chap;		\/\/ 认证方式，长度为 1 字节$/;"	m	struct:portal_ac
parse_array	cJSON.c	/^static const char *parse_array(cJSON *item,const char *value)$/;"	f	file:
parse_number	cJSON.c	/^static const char *parse_number(cJSON *item,const char *num)$/;"	f	file:
parse_object	cJSON.c	/^static const char *parse_object(cJSON *item,const char *value)$/;"	f	file:
parse_string	cJSON.c	/^static const char *parse_string(cJSON *item,const char *str)$/;"	f	file:
parse_value	cJSON.c	/^static const char *parse_value(cJSON *item,const char *value)$/;"	f	file:
password	header.h	/^	char password[PORTAL_PASSWORD_LEN];\/\/查询到的用户登录密码$/;"	m	struct:req_mac_query
password	header.h	/^    char password[PORTAL_PASSWORD_LEN];$/;"	m	struct:req_auth
plat_para	server_mutual.c	/^struct plat_para{$/;"	s	file:
platform_conn_thread	server_mutual.c	/^void* platform_conn_thread(void *fd)$/;"	f
platform_process	server_mutual.c	/^void* platform_process(void *fd)$/;"	f
portal_ac	header.h	/^typedef struct portal_ac$/;"	s
portal_ac_attr	header.h	/^typedef struct portal_ac_attr$/;"	s
prev	cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::
print_array	cJSON.c	/^static char *print_array(cJSON *item,int depth,int fmt)$/;"	f	file:
print_number	cJSON.c	/^static char *print_number(cJSON *item)$/;"	f	file:
print_object	cJSON.c	/^static char *print_object(cJSON *item,int depth,int fmt)$/;"	f	file:
print_string	cJSON.c	/^static char *print_string(cJSON *item)	{return print_string_ptr(item->valuestring);}$/;"	f	file:
print_string_ptr	cJSON.c	/^static char *print_string_ptr(const char *str)$/;"	f	file:
print_value	cJSON.c	/^static char *print_value(cJSON *item,int depth,int fmt)$/;"	f	file:
protal_test_thread	portal.c	/^void* protal_test_thread(void* fd)$/;"	f
radius_attr	radius.c	/^struct radius_attr{$/;"	s	file:
radius_bag	radius.c	/^struct radius_bag{$/;"	s	file:
radius_conn_thread	radius.c	/^void* radius_conn_thread(void *fd)$/;"	f
radius_pro_thread	radius.c	/^void* radius_pro_thread(void *fd)$/;"	f
radius_recv	radius.c	/^struct radius_recv{$/;"	s	file:
reqID	header.h	/^	unsigned short reqID;		\/\/ 2个字节，由AC设备随机生成$/;"	m	struct:portal_ac
req_auth	header.h	/^typedef struct req_auth$/;"	s
req_mac_query	header.h	/^typedef struct req_mac_query$/;"	s
ret	radius.c	/^	int ret;$/;"	m	struct:radius_recv	file:
rsv	header.h	/^	unsigned char rsv;			\/\/ 保留字段，长度为 1 字节，在所有报文中值为 0$/;"	m	struct:portal_ac
run	main.c	/^void run()$/;"	f
serial	header.h	/^	int serial;$/;"	m	struct:req_mac_query
serialNo	header.h	/^	unsigned short serialNo;	\/\/ 报文的序列号，长度为 2 字节$/;"	m	struct:portal_ac
skip	cJSON.c	/^static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}$/;"	f	file:
ssid	server_mutual.c	/^	char* ssid;					\/\/ ssid$/;"	m	struct:plat_para	file:
stat	header.h	/^	int stat;\/\/=1:查询到已存在  =0:没有查询到  =-1:执行查询失败$/;"	m	struct:req_mac_query
string	cJSON.h	/^	char *string;				\/* The item's name string, if this item is the child of, or is in the list of subitems of an object. *\/$/;"	m	struct:cJSON
suffix_object	cJSON.c	/^static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}$/;"	f	file:
type	cJSON.h	/^	int type;					\/* The type of the item, as above. *\/$/;"	m	struct:cJSON
type	header.h	/^	unsigned char type;			\/\/ 报文的类型，长度为 1 字节$/;"	m	struct:portal_ac
type	header.h	/^	unsigned char type;$/;"	m	struct:portal_ac_attr
type	radius.c	/^	unsigned char type;$/;"	m	struct:radius_attr	file:
type	server_mutual.c	/^	char* type;					\/\/ 报文类型 auth-tel, auth-wx, auth-getmac$/;"	m	struct:plat_para	file:
userIP	header.h	/^	unsigned int userIP;		\/\/ Portal用户的IP地址，长度为 4 字节，其值由Portal Server根据其获得的IP地址填写$/;"	m	struct:portal_ac
userName	header.h	/^	char userName[PORTAL_USERNAME_LEN];\/\/查询到的登录用户名$/;"	m	struct:req_mac_query
userPort	header.h	/^	unsigned short userPort;	\/\/ UserPort字段目前没有用到，长度为 2 字节，在所有报文中其值为0$/;"	m	struct:portal_ac
usercode	server_mutual.c	/^	char* usercode;				\/\/ auth-tel：验证码，auth-wx：tid，auth-getmac：空$/;"	m	struct:plat_para	file:
userip	header.h	/^    char userip[PORTAL_IP_LEN];$/;"	m	struct:req_auth
userip	header.h	/^    char userip[PORTAL_IP_LEN];$/;"	m	struct:req_mac_query
usermac	header.h	/^    char usermac[PORTAL_MAC_LEN];$/;"	m	struct:req_mac_query
usernum	server_mutual.c	/^	char* usernum;				\/\/ auth-tel：手机号，auth-wx：微信openid，auth-getmac：空$/;"	m	struct:plat_para	file:
value	radius.c	/^	unsigned char value[0];$/;"	m	struct:radius_attr	file:
valuedouble	cJSON.h	/^	double valuedouble;			\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON
valueint	cJSON.h	/^	int valueint;				\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON
valuestring	cJSON.h	/^	char *valuestring;			\/* The item's string, if type==cJSON_String *\/$/;"	m	struct:cJSON
ver	header.h	/^	unsigned char ver;			\/\/ 协议的版本号，长度为 1 字节，目前定义的值为 0x01$/;"	m	struct:portal_ac
wlanacip	server_mutual.c	/^	char* wlanacip;				\/\/ ac ip$/;"	m	struct:plat_para	file:
wlanacname	server_mutual.c	/^	char* wlanacname;			\/\/ ac标识名称$/;"	m	struct:plat_para	file:
wlanparameter	server_mutual.c	/^	char* wlanparameter;		\/\/ 加密的mac$/;"	m	struct:plat_para	file:
wlanuserfirsturl	server_mutual.c	/^	char* wlanuserfirsturl;		\/\/ 访问的url$/;"	m	struct:plat_para	file:
wlanuserip	server_mutual.c	/^	char* wlanuserip;			\/\/ 用户ip$/;"	m	struct:plat_para	file:
wt_close_sock	net.c	/^void wt_close_sock(int *sock)$/;"	f
wt_recv_block	net.c	/^int wt_recv_block(int sock, unsigned char *buf, int len\/*, int block_flag*\/)$/;"	f
wt_send_block	net.c	/^int wt_send_block(int sock, unsigned char *buf, int len)$/;"	f
wt_setblocking	net.c	/^int inline wt_setblocking(int sockfd)$/;"	f
wt_setnonblocking	net.c	/^int inline wt_setnonblocking(int sockfd)$/;"	f
wt_sock_init	net.c	/^int wt_sock_init(int *sockfd, int port, int listen_num)$/;"	f
xyprintf	logs.c	/^int xyprintf(int err_no, char* format, ...)$/;"	f
xyprintf_plat_para	server_mutual.c	/^void xyprintf_plat_para(struct plat_para *para)$/;"	f
xyprintf_portal_ac	portal.c	/^void xyprintf_portal_ac(ST_PORTAL_AC* pa)$/;"	f
xyprintf_radius_bag	radius.c	/^void xyprintf_radius_bag(struct radius_bag* rb)$/;"	f
